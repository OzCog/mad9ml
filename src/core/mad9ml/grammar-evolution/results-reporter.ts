/**
 * Evolutionary Results Reporter - Comprehensive reporting and documentation for MOSES evolution
 * 
 * Provides transparency, statistics, and insights documentation for grammar evolution results.
 */

import { EvolutionaryResult, MOSESConfig, EvolutionStats } from './types.js';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Generates comprehensive reports for evolutionary results
 */
export class EvolutionaryResultsReporter {
  private outputDir: string;
  private timestamp: string;

  constructor(private config: MOSESConfig) {
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.outputDir = path.join(process.cwd(), 'evolution-results', this.timestamp);
    
    // Create output directory
    if (config.transparency.saveIntermediates) {
      this.ensureDirectoryExists(this.outputDir);
    }
  }

  /**
   * Generates complete evolution report
   */
  async generateReport(result: EvolutionaryResult): Promise<void> {
    console.log('üìä Generating evolutionary results report...');

    if (this.config.transparency.saveIntermediates) {
      await Promise.all([
        this.generateSummaryReport(result),
        this.generateDetailedReport(result),
        this.generateVisualizationData(result),
        this.generateStatisticsReport(result),
        this.generateInsightsReport(result),
        this.saveRawData(result)
      ]);

      console.log(`üìÅ Reports saved to: ${this.outputDir}`);
    } else {
      // Console-only reporting
      this.printConsoleSummary(result);
    }
  }

  /**
   * Generates executive summary report
   */
  private async generateSummaryReport(result: EvolutionaryResult): Promise<void> {
    const summary = this.createSummaryContent(result);
    await this.writeFile('summary.md', summary);
  }

  /**
   * Generates detailed technical report
   */
  private async generateDetailedReport(result: EvolutionaryResult): Promise<void> {
    const detailed = this.createDetailedContent(result);
    await this.writeFile('detailed-report.md', detailed);
  }

  /**
   * Generates data for visualization
   */
  private async generateVisualizationData(result: EvolutionaryResult): Promise<void> {
    const visualData = {
      convergenceData: this.extractConvergenceData(result),
      diversityData: this.extractDiversityData(result),
      fitnessDistribution: this.extractFitnessDistribution(result),
      mutationEffectiveness: result.artifacts.mutationEffectiveness,
      paretoFront: this.extractParetoData(result)
    };

    await this.writeFile('visualization-data.json', JSON.stringify(visualData, null, 2));
    await this.generatePlotScripts(visualData);
  }

  /**
   * Generates statistical analysis report
   */
  private async generateStatisticsReport(result: EvolutionaryResult): Promise<void> {
    const stats = this.createStatisticsContent(result);
    await this.writeFile('statistics.md', stats);
  }

  /**
   * Generates insights and recommendations report
   */
  private async generateInsightsReport(result: EvolutionaryResult): Promise<void> {
    const insights = this.createInsightsContent(result);
    await this.writeFile('insights.md', insights);
  }

  /**
   * Saves raw evolution data
   */
  private async saveRawData(result: EvolutionaryResult): Promise<void> {
    const rawData = {
      bestGenome: result.bestGenome,
      finalPopulation: result.artifacts.finalPopulation,
      convergenceHistory: result.convergenceHistory,
      configuration: this.config
    };

    await this.writeFile('raw-data.json', JSON.stringify(rawData, null, 2));
  }

  /**
   * Creates summary content
   */
  private createSummaryContent(result: EvolutionaryResult): string {
    const runtime = this.calculateRuntime(result);
    const improvement = this.calculateImprovement(result);

    return `# MOSES Grammar Evolution - Executive Summary

## Overview
${result.insights.summary}

## Key Results
- **Best Fitness:** ${result.bestGenome.fitness.toFixed(4)}
- **Runtime:** ${runtime}
- **Generations:** ${result.finalStats.generation}
- **Improvement:** ${improvement}

## Grammar Structure
- **Nodes:** ${result.bestGenome.structure.nodes.length}
- **Edges:** ${result.bestGenome.structure.edges.length}  
- **Patterns:** ${result.bestGenome.structure.patterns.length}

## Key Discoveries
${result.insights.discoveries.map(d => `- ${d}`).join('\n')}

## Recommendations
${result.insights.recommendations.map(r => `- ${r}`).join('\n')}

## Future Directions
${result.insights.futureDirections.map(f => `- ${f}`).join('\n')}

---
*Generated by MOSES Pipeline on ${new Date().toISOString()}*
`;
  }

  /**
   * Creates detailed content
   */
  private createDetailedContent(result: EvolutionaryResult): string {
    return `# MOSES Grammar Evolution - Detailed Technical Report

## Evolution Configuration
${this.formatConfiguration()}

## Best Genome Analysis
${this.formatBestGenome(result.bestGenome)}

## Convergence Analysis
${this.formatConvergenceAnalysis(result)}

## Population Dynamics
${this.formatPopulationDynamics(result)}

## Mutation Analysis
${this.formatMutationAnalysis(result)}

## Pareto Front Analysis
${this.formatParetoAnalysis(result)}

## Lineage Analysis
${this.formatLineageAnalysis(result)}

## Performance Metrics
${this.formatPerformanceMetrics(result)}

---
*Generated by MOSES Pipeline on ${new Date().toISOString()}*
`;
  }

  /**
   * Creates statistics content
   */
  private createStatisticsContent(result: EvolutionaryResult): string {
    const stats = this.calculateDetailedStatistics(result);

    return `# MOSES Grammar Evolution - Statistical Analysis

## Fitness Statistics
- Mean: ${stats.fitness.mean.toFixed(4)}
- Standard Deviation: ${stats.fitness.std.toFixed(4)}
- Minimum: ${stats.fitness.min.toFixed(4)}
- Maximum: ${stats.fitness.max.toFixed(4)}
- Median: ${stats.fitness.median.toFixed(4)}

## Convergence Statistics
- Convergence Rate: ${stats.convergence.rate.toFixed(6)}
- Stagnation Periods: ${stats.convergence.stagnationPeriods}
- Improvement Phases: ${stats.convergence.improvementPhases}

## Diversity Statistics
- Mean Diversity: ${stats.diversity.mean.toFixed(4)}
- Diversity Range: ${stats.diversity.range.toFixed(4)}
- Diversity Trend: ${stats.diversity.trend}

## Structural Statistics
- Node Count Distribution: ${JSON.stringify(stats.structure.nodeDistribution)}
- Edge Count Distribution: ${JSON.stringify(stats.structure.edgeDistribution)}
- Pattern Complexity: ${stats.structure.avgComplexity.toFixed(3)}

## Performance Statistics
- Average Generation Time: ${stats.performance.avgGenerationTime.toFixed(2)}ms
- Evaluations per Second: ${stats.performance.evaluationsPerSecond.toFixed(1)}
- Memory Efficiency: ${stats.performance.memoryEfficiency.toFixed(2)}MB/genome

---
*Generated by MOSES Pipeline on ${new Date().toISOString()}*
`;
  }

  /**
   * Creates insights content
   */
  private createInsightsContent(result: EvolutionaryResult): string {
    return `# MOSES Grammar Evolution - Insights and Discoveries

## Summary
${result.insights.summary}

## Detailed Discoveries

### Structural Evolution
${this.analyzeStructuralEvolution(result)}

### Performance Evolution  
${this.analyzePerformanceEvolution(result)}

### Emergent Behaviors
${this.analyzeEmergentBehaviors(result)}

## Key Insights

### What Worked Well
${this.identifySuccessFactors(result)}

### Challenges Encountered
${this.identifyChallenges(result)}

### Unexpected Findings
${this.identifyUnexpectedFindings(result)}

## Recommendations for Future Work

### Parameter Optimization
${result.insights.recommendations.filter(r => r.includes('parameter')).map(r => `- ${r}`).join('\n')}

### Algorithmic Improvements
${result.insights.recommendations.filter(r => r.includes('algorithm')).map(r => `- ${r}`).join('\n')}

### Research Directions
${result.insights.futureDirections.map(f => `- ${f}`).join('\n')}

## Meta-Cognitive Insights
${this.generateMetaCognitiveInsights(result)}

---
*Generated by MOSES Pipeline on ${new Date().toISOString()}*
`;
  }

  /**
   * Formats best genome information
   */
  private formatBestGenome(genome: any): string {
    return `
### Structure
- **ID:** ${genome.id}
- **Generation:** ${genome.generation}
- **Fitness:** ${genome.fitness.toFixed(4)}
- **Lineage:** ${genome.lineage.join(' ‚Üí ')}

### Components
- **Primitives:** ${genome.primitives.length}
- **Nodes:** ${genome.structure.nodes.length}
- **Edges:** ${genome.structure.edges.length}
- **Patterns:** ${genome.structure.patterns.length}

### Parameter Tensors
${Object.keys(genome.parameters).map(key => 
  `- **${key}:** Shape ${JSON.stringify(genome.parameters[key].shape)}, Norm: ${this.calculateTensorNorm(genome.parameters[key]).toFixed(3)}`
).join('\n')}
`;
  }

  /**
   * Formats convergence analysis
   */
  private formatConvergenceAnalysis(result: EvolutionaryResult): string {
    const history = result.convergenceHistory;
    const phases = this.identifyConvergencePhases(history);

    return `
### Convergence Phases
${phases.map((phase, i) => 
  `**Phase ${i + 1}** (Gen ${phase.start}-${phase.end}): ${phase.description}`
).join('\n')}

### Convergence Metrics
- **Final Convergence Rate:** ${result.finalStats.convergence.rate.toFixed(6)}
- **Total Stagnation:** ${result.finalStats.convergence.stagnationCount} generations
- **Fitness Variance:** ${result.finalStats.convergence.fitnessVariance.toFixed(4)}
`;
  }

  /**
   * Console-only summary for minimal reporting
   */
  private printConsoleSummary(result: EvolutionaryResult): void {
    console.log('\nüéØ MOSES Evolution Summary:');
    console.log(`  Best Fitness: ${result.bestGenome.fitness.toFixed(4)}`);
    console.log(`  Generations: ${result.finalStats.generation}`);
    console.log(`  Structure: ${result.bestGenome.structure.nodes.length} nodes, ${result.bestGenome.structure.edges.length} edges`);
    console.log(`  Key Discoveries: ${result.insights.discoveries.length}`);
    
    if (result.insights.discoveries.length > 0) {
      console.log('\nüîç Top Discoveries:');
      result.insights.discoveries.slice(0, 3).forEach(d => console.log(`  ‚Ä¢ ${d}`));
    }
    
    if (result.insights.recommendations.length > 0) {
      console.log('\nüí° Key Recommendations:');
      result.insights.recommendations.slice(0, 3).forEach(r => console.log(`  ‚Ä¢ ${r}`));
    }
  }

  /**
   * Helper methods for data extraction and analysis
   */
  private extractConvergenceData(result: EvolutionaryResult): any {
    return result.convergenceHistory.map(stat => ({
      generation: stat.generation,
      bestFitness: stat.population.bestFitness,
      avgFitness: stat.population.averageFitness,
      convergenceRate: stat.convergence.rate
    }));
  }

  private extractDiversityData(result: EvolutionaryResult): any {
    return result.convergenceHistory.map(stat => ({
      generation: stat.generation,
      diversity: stat.population.diversity,
      fitnessVariance: stat.convergence.fitnessVariance
    }));
  }

  private extractFitnessDistribution(result: EvolutionaryResult): any {
    return result.artifacts.finalPopulation.map(genome => ({
      id: genome.id,
      fitness: genome.fitness,
      generation: genome.generation,
      complexity: genome.structure.nodes.length + genome.structure.edges.length
    }));
  }

  private extractParetoData(result: EvolutionaryResult): any {
    return result.paretoFront?.map(genome => ({
      fitness: genome.fitness,
      complexity: genome.structure.nodes.length + genome.structure.edges.length,
      patterns: genome.structure.patterns.length
    })) || [];
  }

  private calculateDetailedStatistics(result: EvolutionaryResult): any {
    const fitnesses = result.convergenceHistory.map(s => s.population.bestFitness);
    const diversities = result.convergenceHistory.map(s => s.population.diversity);
    
    return {
      fitness: {
        mean: this.mean(fitnesses),
        std: this.standardDeviation(fitnesses),
        min: Math.min(...fitnesses),
        max: Math.max(...fitnesses),
        median: this.median(fitnesses)
      },
      convergence: {
        rate: result.finalStats.convergence.rate,
        stagnationPeriods: this.countStagnationPeriods(result.convergenceHistory),
        improvementPhases: this.countImprovementPhases(result.convergenceHistory)
      },
      diversity: {
        mean: this.mean(diversities),
        range: Math.max(...diversities) - Math.min(...diversities),
        trend: this.calculateTrend(diversities)
      },
      structure: {
        nodeDistribution: this.calculateNodeDistribution(result.artifacts.finalPopulation),
        edgeDistribution: this.calculateEdgeDistribution(result.artifacts.finalPopulation),
        avgComplexity: this.calculateAverageComplexity(result.artifacts.finalPopulation)
      },
      performance: {
        avgGenerationTime: this.calculateAvgGenerationTime(result.convergenceHistory),
        evaluationsPerSecond: this.calculateAvgEvaluationsPerSecond(result.convergenceHistory),
        memoryEfficiency: this.calculateMemoryEfficiency(result.artifacts.finalPopulation)
      }
    };
  }

  private generatePlotScripts(visualData: any): Promise<void> {
    const pythonScript = `
import matplotlib.pyplot as plt
import json
import numpy as np

# Load data
with open('visualization-data.json', 'r') as f:
    data = json.load(f)

# Create convergence plot
plt.figure(figsize=(12, 8))

plt.subplot(2, 2, 1)
convergence = data['convergenceData']
generations = [d['generation'] for d in convergence]
best_fitness = [d['bestFitness'] for d in convergence]
avg_fitness = [d['avgFitness'] for d in convergence]

plt.plot(generations, best_fitness, 'b-', label='Best Fitness', linewidth=2)
plt.plot(generations, avg_fitness, 'r--', label='Average Fitness', linewidth=1)
plt.xlabel('Generation')
plt.ylabel('Fitness')
plt.title('Fitness Convergence')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(2, 2, 2)
diversity = data['diversityData']
diversity_values = [d['diversity'] for d in diversity]
plt.plot(generations, diversity_values, 'g-', linewidth=2)
plt.xlabel('Generation')
plt.ylabel('Population Diversity')
plt.title('Population Diversity Over Time')
plt.grid(True, alpha=0.3)

plt.subplot(2, 2, 3)
fitness_dist = data['fitnessDistribution']
fitnesses = [d['fitness'] for d in fitness_dist]
plt.hist(fitnesses, bins=20, alpha=0.7, color='skyblue', edgecolor='black')
plt.xlabel('Fitness')
plt.ylabel('Frequency')
plt.title('Final Population Fitness Distribution')
plt.grid(True, alpha=0.3)

plt.subplot(2, 2, 4)
if data['paretoFront']:
    pareto = data['paretoFront']
    pareto_fitness = [p['fitness'] for p in pareto]
    pareto_complexity = [p['complexity'] for p in pareto]
    plt.scatter(pareto_complexity, pareto_fitness, c='red', s=50, alpha=0.7)
    plt.xlabel('Complexity')
    plt.ylabel('Fitness')
    plt.title('Pareto Front')
    plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('evolution-analysis.png', dpi=300, bbox_inches='tight')
plt.show()

print("Visualization complete! Check evolution-analysis.png")
`;

    return this.writeFile('generate_plots.py', pythonScript);
  }

  /**
   * Analysis helper methods
   */
  private analyzeStructuralEvolution(result: EvolutionaryResult): string {
    const best = result.bestGenome;
    const insights: string[] = [];
    
    if (best.structure.nodes.length > 8) {
      insights.push('- Evolved complex multi-node architectures');
    }
    
    if (best.structure.edges.length > best.structure.nodes.length * 1.5) {
      insights.push('- Developed highly connected network topologies');
    }
    
    if (best.structure.patterns.length > 3) {
      insights.push('- Emerged sophisticated pattern libraries');
    }
    
    return insights.join('\n') || '- No significant structural insights identified';
  }

  private analyzePerformanceEvolution(result: EvolutionaryResult): string {
    const history = result.convergenceHistory;
    const insights: string[] = [];
    
    const improvementRate = this.calculateOverallImprovementRate(history);
    if (improvementRate > 0.01) {
      insights.push('- Demonstrated rapid fitness improvement');
    } else if (improvementRate < 0.001) {
      insights.push('- Showed gradual, steady improvement');
    }
    
    const finalPerformance = history[history.length - 1].performance;
    if (finalPerformance.generationsPerSecond > 1) {
      insights.push('- Maintained efficient evolution speed');
    }
    
    return insights.join('\n') || '- Standard performance evolution observed';
  }

  private analyzeEmergentBehaviors(result: EvolutionaryResult): string {
    const insights: string[] = [];
    
    // Check for emergent patterns in final stats
    if (result.finalStats.insights.emergedPatterns.length > 0) {
      insights.push(`- Emerged patterns: ${result.finalStats.insights.emergedPatterns.join(', ')}`);
    }
    
    if (result.finalStats.insights.unexpectedBehaviors.length > 0) {
      insights.push(`- Unexpected behaviors: ${result.finalStats.insights.unexpectedBehaviors.join(', ')}`);
    }
    
    // Analyze lineage diversity
    const uniqueLineages = new Set(Object.values(result.artifacts.lineageTree).map(l => l.length));
    if (uniqueLineages.size > 3) {
      insights.push('- Diverse evolutionary lineages developed');
    }
    
    return insights.join('\n') || '- No notable emergent behaviors detected';
  }

  private identifySuccessFactors(result: EvolutionaryResult): string {
    const factors: string[] = [];
    
    if (result.bestGenome.fitness > 0.8) {
      factors.push('- High-quality fitness function design');
    }
    
    if (result.finalStats.population.diversity > 0.3) {
      factors.push('- Effective diversity maintenance');
    }
    
    const improvementPhases = this.countImprovementPhases(result.convergenceHistory);
    if (improvementPhases > 3) {
      factors.push('- Multiple improvement phases achieved');
    }
    
    return factors.join('\n') || '- Standard evolutionary dynamics observed';
  }

  private identifyChallenges(result: EvolutionaryResult): string {
    const challenges: string[] = [];
    
    if (result.finalStats.convergence.stagnationCount > 20) {
      challenges.push('- Extended stagnation periods encountered');
    }
    
    if (result.finalStats.population.diversity < 0.2) {
      challenges.push('- Population diversity loss');
    }
    
    if (result.convergenceHistory.length > 100 && result.bestGenome.fitness < 0.7) {
      challenges.push('- Slow convergence to high-quality solutions');
    }
    
    return challenges.join('\n') || '- No significant challenges identified';
  }

  private identifyUnexpectedFindings(result: EvolutionaryResult): string {
    const findings: string[] = [];
    
    // Look for fitness jumps
    for (let i = 1; i < result.convergenceHistory.length; i++) {
      const improvement = result.convergenceHistory[i].population.bestFitness - 
                         result.convergenceHistory[i-1].population.bestFitness;
      if (improvement > 0.1) {
        findings.push(`- Significant fitness jump at generation ${result.convergenceHistory[i].generation}`);
        break;
      }
    }
    
    // Check for unusual structural evolution
    const finalComplexity = result.bestGenome.structure.nodes.length + result.bestGenome.structure.edges.length;
    if (finalComplexity > 20) {
      findings.push('- Unexpectedly complex final structures evolved');
    } else if (finalComplexity < 5) {
      findings.push('- Minimalist structures achieved high fitness');
    }
    
    return findings.join('\n') || '- No unexpected findings noted';
  }

  private generateMetaCognitiveInsights(result: EvolutionaryResult): string {
    const insights: string[] = [];
    
    insights.push('### Evolution Strategy Effectiveness');
    insights.push('The evolutionary process demonstrated several meta-cognitive properties:');
    
    if (result.finalStats.mutation.adaptationHistory.length > 5) {
      insights.push('- Adaptive mutation rate adjustment was active throughout evolution');
    }
    
    const diversityMaintenance = result.convergenceHistory.every(s => s.population.diversity > 0.1);
    if (diversityMaintenance) {
      insights.push('- Consistent diversity maintenance prevented premature convergence');
    }
    
    insights.push('\n### Self-Organizational Properties');
    const paretoSize = result.paretoFront?.length || 0;
    if (paretoSize > 5) {
      insights.push('- Multi-objective optimization created diverse solution spaces');
    }
    
    insights.push('\n### Emergent Complexity');
    const avgComplexity = this.calculateAverageComplexity(result.artifacts.finalPopulation);
    if (avgComplexity > 0.5) {
      insights.push('- Population evolved toward optimal complexity levels');
    } else {
      insights.push('- Evolution favored simpler, more efficient solutions');
    }
    
    return insights.join('\n');
  }

  /**
   * Statistical helper methods
   */
  private mean(values: number[]): number {
    return values.reduce((sum, v) => sum + v, 0) / values.length;
  }

  private standardDeviation(values: number[]): number {
    const avg = this.mean(values);
    const variance = values.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / values.length;
    return Math.sqrt(variance);
  }

  private median(values: number[]): number {
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
  }

  private calculateTrend(values: number[]): string {
    if (values.length < 2) return 'insufficient data';
    
    const firstHalf = values.slice(0, Math.floor(values.length / 2));
    const secondHalf = values.slice(Math.floor(values.length / 2));
    
    const firstAvg = this.mean(firstHalf);
    const secondAvg = this.mean(secondHalf);
    
    const change = secondAvg - firstAvg;
    if (change > 0.01) return 'increasing';
    if (change < -0.01) return 'decreasing';
    return 'stable';
  }

  private countStagnationPeriods(history: EvolutionStats[]): number {
    let periods = 0;
    let currentStagnation = 0;
    
    for (let i = 1; i < history.length; i++) {
      const improvement = history[i].population.bestFitness - history[i-1].population.bestFitness;
      if (improvement < 0.001) {
        currentStagnation++;
      } else {
        if (currentStagnation > 5) periods++;
        currentStagnation = 0;
      }
    }
    
    return periods;
  }

  private countImprovementPhases(history: EvolutionStats[]): number {
    let phases = 0;
    let inPhase = false;
    
    for (let i = 1; i < history.length; i++) {
      const improvement = history[i].population.bestFitness - history[i-1].population.bestFitness;
      if (improvement > 0.01) {
        if (!inPhase) {
          phases++;
          inPhase = true;
        }
      } else {
        inPhase = false;
      }
    }
    
    return phases;
  }

  private calculateNodeDistribution(population: any[]): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    for (const genome of population) {
      const nodeCount = genome.structure.nodes.length;
      const key = `${nodeCount}-nodes`;
      distribution[key] = (distribution[key] || 0) + 1;
    }
    
    return distribution;
  }

  private calculateEdgeDistribution(population: any[]): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    for (const genome of population) {
      const edgeCount = genome.structure.edges.length;
      const key = `${edgeCount}-edges`;
      distribution[key] = (distribution[key] || 0) + 1;
    }
    
    return distribution;
  }

  private calculateAverageComplexity(population: any[]): number {
    const complexities = population.map(genome => 
      genome.structure.nodes.length + genome.structure.edges.length + genome.structure.patterns.length
    );
    
    return this.mean(complexities) / 20; // Normalize by expected max complexity
  }

  private calculateAvgGenerationTime(history: EvolutionStats[]): number {
    const times = history.map(s => 1000 / s.performance.generationsPerSecond);
    return this.mean(times);
  }

  private calculateAvgEvaluationsPerSecond(history: EvolutionStats[]): number {
    const rates = history.map(s => s.performance.evaluationsPerSecond);
    return this.mean(rates);
  }

  private calculateMemoryEfficiency(population: any[]): number {
    // Simplified memory estimation
    return population.length * 0.1; // Approximate MB per genome
  }

  private calculateRuntime(result: EvolutionaryResult): string {
    const totalTime = result.convergenceHistory.reduce((sum, s) => sum + (1000 / s.performance.generationsPerSecond), 0);
    
    if (totalTime < 60000) {
      return `${(totalTime / 1000).toFixed(1)}s`;
    } else {
      return `${(totalTime / 60000).toFixed(1)}m`;
    }
  }

  private calculateImprovement(result: EvolutionaryResult): string {
    if (result.convergenceHistory.length < 2) return 'N/A';
    
    const initial = result.convergenceHistory[0].population.bestFitness;
    const final = result.bestGenome.fitness;
    const improvement = ((final - initial) / initial * 100);
    
    return `${improvement.toFixed(1)}%`;
  }

  private calculateOverallImprovementRate(history: EvolutionStats[]): number {
    if (history.length < 2) return 0;
    
    const initial = history[0].population.bestFitness;
    const final = history[history.length - 1].population.bestFitness;
    
    return (final - initial) / history.length;
  }

  private calculateTensorNorm(tensor: any): number {
    const data = tensor.data as Float32Array;
    return Math.sqrt(data.reduce((sum: number, val: number) => sum + val * val, 0));
  }

  private identifyConvergencePhases(history: EvolutionStats[]): any[] {
    const phases: any[] = [];
    let currentPhase = { start: 0, end: 0, description: 'Initial phase' };
    
    for (let i = 1; i < history.length; i++) {
      const improvement = history[i].population.bestFitness - history[i-1].population.bestFitness;
      
      if (improvement > 0.01) {
        if (currentPhase.description !== 'Rapid improvement') {
          if (currentPhase.end > currentPhase.start) phases.push(currentPhase);
          currentPhase = { start: i, end: i, description: 'Rapid improvement' };
        } else {
          currentPhase.end = i;
        }
      } else if (improvement < -0.001) {
        if (currentPhase.description !== 'Fitness decline') {
          if (currentPhase.end > currentPhase.start) phases.push(currentPhase);
          currentPhase = { start: i, end: i, description: 'Fitness decline' };
        } else {
          currentPhase.end = i;
        }
      } else {
        if (currentPhase.description !== 'Stagnation') {
          if (currentPhase.end > currentPhase.start) phases.push(currentPhase);
          currentPhase = { start: i, end: i, description: 'Stagnation' };
        } else {
          currentPhase.end = i;
        }
      }
    }
    
    if (currentPhase.end > currentPhase.start) phases.push(currentPhase);
    
    return phases;
  }

  private formatConfiguration(): string {
    return `
- **Objective:** ${this.config.objective}
- **Meta-optimization:** ${this.config.metaOptimization}
- **Transparency Level:** ${this.config.transparency.logLevel}
- **Parallelization:** ${this.config.parallelization.enabled}
- **Memory Management:** Archive size ${this.config.memoryManagement.archiveSize}
`;
  }

  private formatPopulationDynamics(result: EvolutionaryResult): string {
    const history = result.convergenceHistory;
    const avgDiversity = this.mean(history.map(s => s.population.diversity));
    const diversityTrend = this.calculateTrend(history.map(s => s.population.diversity));
    
    return `
### Diversity Metrics
- **Average Diversity:** ${avgDiversity.toFixed(4)}
- **Diversity Trend:** ${diversityTrend}
- **Final Diversity:** ${result.finalStats.population.diversity.toFixed(4)}

### Population Size
- **Configured Size:** ${result.finalStats.population.size}
- **Elite Preservation:** Active
- **Selection Pressure:** Moderate
`;
  }

  private formatMutationAnalysis(result: EvolutionaryResult): string {
    const mutationData = result.artifacts.mutationEffectiveness;
    const avgEffectiveness = Object.values(mutationData).reduce((sum, val) => sum + (val as number), 0) / Object.keys(mutationData).length;
    
    return `
### Mutation Effectiveness
- **Average Effectiveness:** ${avgEffectiveness.toFixed(4)}
- **Most Effective Mutations:** ${Object.entries(mutationData)
  .sort(([,a], [,b]) => (b as number) - (a as number))
  .slice(0, 3)
  .map(([type, eff]) => `${type} (${(eff as number).toFixed(3)})`)
  .join(', ')}

### Adaptive Mutation
- **Final Rate:** ${result.finalStats.mutation.currentRate.toFixed(4)}
- **Effective Rate:** ${result.finalStats.mutation.effectiveRate.toFixed(4)}
- **Adaptation Active:** ${result.finalStats.mutation.adaptationHistory.length > 5}
`;
  }

  private formatParetoAnalysis(result: EvolutionaryResult): string {
    if (!result.paretoFront || result.paretoFront.length === 0) {
      return 'No Pareto front analysis available (single-objective optimization)';
    }
    
    const paretoSize = result.paretoFront.length;
    const fitnessRange = Math.max(...result.paretoFront.map(g => g.fitness)) - 
                        Math.min(...result.paretoFront.map(g => g.fitness));
    
    return `
### Pareto Front Characteristics
- **Front Size:** ${paretoSize} solutions
- **Fitness Range:** ${fitnessRange.toFixed(4)}
- **Diversity:** Multi-objective trade-offs identified
- **Dominance:** Non-dominated solutions preserved
`;
  }

  private formatLineageAnalysis(result: EvolutionaryResult): string {
    const lineageTree = result.artifacts.lineageTree;
    const avgLineageDepth = Object.values(lineageTree).reduce((sum, lineage) => sum + lineage.length, 0) / Object.keys(lineageTree).length;
    const maxLineageDepth = Math.max(...Object.values(lineageTree).map(lineage => lineage.length));
    
    return `
### Lineage Characteristics
- **Average Lineage Depth:** ${avgLineageDepth.toFixed(1)}
- **Maximum Lineage Depth:** ${maxLineageDepth}
- **Lineage Diversity:** ${Object.keys(lineageTree).length} unique lineages
- **Best Genome Lineage:** ${result.bestGenome.lineage.join(' ‚Üí ')}
`;
  }

  private formatPerformanceMetrics(result: EvolutionaryResult): string {
    const finalPerf = result.finalStats.performance;
    
    return `
### Computational Performance
- **Generations per Second:** ${finalPerf.generationsPerSecond.toFixed(2)}
- **Evaluations per Second:** ${finalPerf.evaluationsPerSecond.toFixed(1)}
- **Memory Usage:** ${(finalPerf.memoryUsage / (1024 * 1024)).toFixed(1)} MB
- **CPU Efficiency:** Optimized for single-core execution

### Scalability Metrics
- **Population Scaling:** Linear with population size
- **Generation Scaling:** Constant time per generation
- **Memory Efficiency:** ${(finalPerf.memoryUsage / result.finalStats.population.size / 1024).toFixed(1)} KB per genome
`;
  }

  /**
   * File I/O helpers
   */
  private ensureDirectoryExists(dir: string): void {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  private async writeFile(filename: string, content: string): Promise<void> {
    const filepath = path.join(this.outputDir, filename);
    return new Promise((resolve, reject) => {
      fs.writeFile(filepath, content, 'utf8', (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
}